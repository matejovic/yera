import {
  F as F2,
  _,
  h,
  q,
  s,
  y as y2
} from "./chunk-LVTKPAWT.js";
import {
  B,
  C,
  E,
  F,
  G,
  l,
  y
} from "./chunk-CTSDWTOA.js";
import "./chunk-76J2PTFD.js";

// node_modules/preact-iso/src/router.js
var push;
var UPDATE = (state, url) => {
  push = void 0;
  if (url && url.type === "click") {
    if (url.ctrlKey || url.metaKey || url.altKey || url.shiftKey || url.button !== 0) {
      return state;
    }
    const link = url.target.closest("a[href]");
    if (!link || link.origin != location.origin || /^#/.test(link.getAttribute("href")) || !/^(_?self)?$/i.test(link.target)) {
      return state;
    }
    push = true;
    url.preventDefault();
    url = link.href.replace(location.origin, "");
  } else if (typeof url === "string") {
    push = true;
  } else {
    url = location.pathname + location.search;
  }
  if (push === true)
    history.pushState(null, "", url);
  else if (push === false)
    history.replaceState(null, "", url);
  return url;
};
var exec = (url, route, matches) => {
  url = url.split("/").filter(Boolean);
  route = (route || "").split("/").filter(Boolean);
  for (let i = 0, val, rest; i < Math.max(url.length, route.length); i++) {
    let [, m, param, flag] = (route[i] || "").match(/^(:?)(.*?)([+*?]?)$/);
    val = url[i];
    if (!m && param == val)
      continue;
    if (!m && val && flag == "*") {
      matches.rest = "/" + url.slice(i).map(decodeURIComponent).join("/");
      break;
    }
    if (!m || !val && flag != "?" && flag != "*")
      return;
    rest = flag == "+" || flag == "*";
    if (rest)
      val = url.slice(i).map(decodeURIComponent).join("/");
    else if (val)
      val = decodeURIComponent(val);
    matches.params[param] = val;
    if (!(param in matches))
      matches[param] = val;
    if (rest)
      break;
  }
  return matches;
};
function LocationProvider(props) {
  const [url, route] = s(UPDATE, props.url || location.pathname + location.search);
  const wasPush = push === true;
  const value = F2(() => {
    const u = new URL(url, location.origin);
    const path = u.pathname.replace(/(.)\/$/g, "$1");
    return { url, path, query: Object.fromEntries(u.searchParams), route, wasPush };
  }, [url]);
  y2(() => {
    addEventListener("click", route);
    addEventListener("popstate", route);
    return () => {
      removeEventListener("click", route);
      removeEventListener("popstate", route);
    };
  }, []);
  return y(LocationProvider.ctx.Provider, { value }, props.children);
}
var RESOLVED = Promise.resolve();
function Router(props) {
  const [c, update] = s((c2) => c2 + 1, 0);
  const { url, query, wasPush, path } = useLocation();
  const { rest = path, params = {} } = q(RouteContext);
  const isLoading = _(false);
  const prevRoute = _(path);
  const count = _(0);
  const cur = _();
  const prev = _();
  const pendingBase = _();
  const hasEverCommitted = _(false);
  const didSuspend = _();
  didSuspend.current = false;
  cur.current = F2(() => {
    if (this.__v && this.__v.__k)
      this.__v.__k.reverse();
    count.current++;
    prev.current = cur.current;
    let p2, d, m;
    C(props.children).some((vnode) => {
      const matches = exec(rest, vnode.props.path, m = { path: rest, query, params, rest: "" });
      if (matches)
        return p2 = F(vnode, m);
      if (vnode.props.default)
        d = F(vnode, m);
    });
    return y(RouteContext.Provider, { value: m }, p2 || d);
  }, [url]);
  const p = prev.current;
  prev.current = null;
  this.__c = (e) => {
    didSuspend.current = true;
    prev.current = p;
    if (props.onLoadStart)
      props.onLoadStart(url);
    isLoading.current = true;
    let c2 = count.current;
    e.then(() => {
      if (c2 !== count.current)
        return;
      prev.current = null;
      RESOLVED.then(update);
    });
  };
  y2(() => {
    const currentDom = this.__v && this.__v.__e;
    if (didSuspend.current) {
      if (!hasEverCommitted.current && !pendingBase.current) {
        pendingBase.current = currentDom;
      }
      return;
    }
    if (!hasEverCommitted.current && pendingBase.current) {
      if (pendingBase.current !== currentDom)
        pendingBase.current.remove();
      pendingBase.current = null;
    }
    hasEverCommitted.current = true;
    if (prevRoute.current !== path) {
      if (wasPush)
        scrollTo(0, 0);
      if (props.onLoadEnd && isLoading.current)
        props.onLoadEnd(url);
      if (props.onRouteChange)
        props.onRouteChange(url);
      isLoading.current = false;
      prevRoute.current = path;
    }
  }, [path, wasPush, c]);
  return [y(RenderRef, { r: cur }), y(RenderRef, { r: prev })];
}
var RenderRef = ({ r }) => r.current;
Router.Provider = LocationProvider;
LocationProvider.ctx = G(
  /** @type {RouteInfo} */
  {}
);
var RouteContext = G({});
var Route = (props) => y(props.component, props);
var useLocation = () => q(LocationProvider.ctx);
var useRoute = () => q(RouteContext);

// node_modules/preact-iso/src/lazy.js
function lazy(load) {
  let p, c;
  return (props) => {
    const [, update] = h(0);
    const r = _(c);
    if (!p)
      p = load().then((m) => c = m && m.default || m);
    if (c !== void 0)
      return y(c, props);
    if (!r.current)
      r.current = p.then(() => update(1));
    throw p;
  };
}
var oldCatchError = l.__e;
l.__e = (err, newVNode, oldVNode) => {
  if (err && err.then) {
    let v = newVNode;
    while (v = v.__) {
      if (v.__c && v.__c.__c) {
        if (newVNode.__e == null) {
          newVNode.__e = oldVNode.__e;
          newVNode.__k = oldVNode.__k;
        }
        if (!newVNode.__k)
          newVNode.__k = [];
        return v.__c.__c(err, newVNode);
      }
    }
  }
  if (oldCatchError)
    oldCatchError(err, newVNode, oldVNode);
};
function ErrorBoundary(props) {
  this.__c = childDidSuspend;
  this.componentDidCatch = props.onError;
  return props.children;
}
function childDidSuspend(err) {
  err.then(() => this.forceUpdate());
}

// node_modules/preact-iso/src/hydrate.js
var initialized;
function hydrate(jsx, parent) {
  if (typeof window === "undefined")
    return;
  let isodata = document.querySelector("script[type=isodata]");
  parent = parent || isodata && isodata.parentNode || document.body;
  if (!initialized && isodata) {
    E(jsx, parent);
  } else {
    B(jsx, parent);
  }
  initialized = true;
}

// node_modules/preact-iso/src/index.js
function prerender(vnode, options) {
  return import("./prerender-AE5IIH7Q.js").then((m) => m.default(vnode, options));
}
export {
  ErrorBoundary,
  LocationProvider,
  Route,
  Router,
  hydrate,
  lazy,
  prerender,
  useLocation,
  useRoute
};
//# sourceMappingURL=preact-iso.js.map
